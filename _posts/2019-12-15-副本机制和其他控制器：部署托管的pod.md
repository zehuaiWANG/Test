---
layout:     post
title:      "副本机制和其他控制器：部署托管的pod"
subtitle:   " \"Kubernetes\""
date:       2019-12-15 12:00:00
author:     "edsel"
header-img: "img/2.png"
catalog: true
tags:
    - kubernetes
---

> “Pod是kubernetes中的基本部署单元，我们可以直接创建、监督和管理一个pod。kubernetes会监控pod中部署的容器，在他们失败的时候重新启动他们，但如果整个节点失败，那么节点上的pod会丢失，并不会被新的节点替换。在实际使用中，我们希望pod能自动运行并保持健康，无需干预，所以我们会使用ReplicationController或者deployment一样的资源来创建和管理实际中的pod ”

### 保持pod健康

pod调度到kubernetes的节点中，该节点上的kubelet就会运行pod中的容器，如果pod的主进程崩溃或停止工作，kubelet会重启容器，但是，如果应用程序由于死循环而停止响应（这时候应用程序没办法从内部感知，主程序并没有奔溃），为确保应用程序能在这种情况下重启，就必须从外部检查应用程序的运行状态。

#### 存活探针

kubernetes可以通过存活探针（liveness probe）来检查容器是否还在运行。可以为pod中的每个容器单独指定存活探针。如果探测失败，kubernetes将定期执行探针并重新启动容器。

kubernetes有以下三种探测容器的机制：

- HTTP GET探针，针对容器的IP地址执行HTTP GET请求，如果响应状态码不代表错误，则认为探测成功，如果服务器返回错误响应码或者没有响应，则认为探测失败，容器将被重新启动。
- TCP套接字，尝试与容器指定端口建立TCP连接，如果连接成功则探测成功。
- Exec探针在容器内执行任何命令，并检查命令退出状态码。如果状态码是0，则探测成功。

#### 创建基于HTTP的存活探针

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: kubia-liveness
spec:
  containers:
  - image: luksa/kubia-unhealthy
    name: kubia
    livenessProbe:
      httpGet:
        path: /
        port: 8080
```

`luksa/kubia-unhealthy`是一个被请求五次就会返回500的镜像，我们创建该镜像，在running之后大概2分钟，我们可以通过:

```shell
# kubectl get po kubia-liveness
NAME             READY   STATUS    RESTARTS   AGE
kubia-liveness   1/1     Running   1          2m38s
```

看到他已经重启了。

我们可以通过`kubectl logs kubia-liveness --previous`来看到前一个容器的日志。

也可以通过`kubectl describe po kubia-liveness`来知道为什么容器重启。

ps：可以看到退出状态码为137，137 = 128 + 9（128是无效退出参数，9是终止进程的额信号编号，9是SIGKILL的信号编号），Events中可以看到重启的原因 `Liveness probe failed: HTTP probe failed with statuscode: 500`

#### 配置存活探针的附加属性

通过`kubectl describe po kubia-liveness`我们还可以探针的其他属性

```
Liveness:       http-get http://:8080/ delay=0s timeout=1s period=10s #success=1 #failure=3
```

delay=0s 表示容器启动后立即开始探测，timeout=1s 表示一秒内必须响应，period=10s 表示每过10s探测一次，#failure=3 表示探测失败三次后重启。